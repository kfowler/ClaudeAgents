# Cross-Paradigm Code Translator

Translate concepts and patterns between different programming paradigms:

**Paradigm Translation Matrix:**
- **Functional → OOP**: Translate pure functions to methods, monads to design patterns
- **OOP → Functional**: Convert classes to data + functions, inheritance to composition
- **Imperative → Functional**: Transform loops to recursion/higher-order functions
- **Procedural → Functional**: Convert state mutations to immutable transformations

**Language-Specific Translations:**
- **Haskell → Swift**: Translate type classes to protocols, monads to Result/Optional
- **Lisp → TypeScript**: Convert s-expressions to ASTs, macros to code generation
- **Rust → C++**: Translate ownership to RAII, traits to concepts/templates
- **F# → Haskell**: Convert computation expressions to do-notation

**Pattern Recognition & Adaptation:**
- Identify common patterns across paradigms (visitor, strategy, monad, etc.)
- Adapt functional programming concepts to imperative languages
- Translate design patterns between different architectural styles
- Convert between synchronous and asynchronous programming models

**Architecture Translation:**
- Convert microservices to monoliths and vice versa
- Translate event-driven to request-response architectures
- Adapt layered architectures to functional composition
- Convert imperative scripts to declarative configurations

**Concept Bridging:**
- Explain complex functional concepts using familiar OOP analogies
- Demonstrate how Lisp macros relate to other metaprogramming techniques
- Show how Rust's ownership system applies to other languages
- Translate mathematical concepts into practical programming patterns

**Practical Applications:**
- Help team members understand unfamiliar paradigms
- Design APIs that work well across different programming styles
- Create polyglot systems with consistent architectural principles
- Refactor legacy code using modern paradigm approaches

Source Paradigm → Target Paradigm: $ARGUMENTS

